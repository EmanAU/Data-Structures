/*
====================================================================
        SORTING ALGORITHMS ‚Äì COMPARISON & BEST USE CASES
====================================================================

Algorithms Covered:
‚úî Bubble Sort
‚úî Insertion Sort
‚úî Selection Sort
‚úî Radix Sort
‚úî Merge Sort
‚úî Quick Sort

--------------------------------------------------------------------
1Ô∏è‚É£ BUBBLE SORT
--------------------------------------------------------------------
TYPE:
- Comparison-based
- Simple sort

TIME COMPLEXITY:
- Best:    O(n)
- Average: O(n¬≤)
- Worst:   O(n¬≤)

SPACE:
- O(1) (in-place)

STABLE:
- YES

PROS:
- Very easy to understand
- Works well for very small data

CONS:
- Extremely slow for large inputs

BEST USED WHEN:
‚úî Very small datasets
‚úî Nearly sorted arrays
‚úî Learning basics

--------------------------------------------------------------------
2Ô∏è‚É£ INSERTION SORT
--------------------------------------------------------------------
TYPE:
- Comparison-based

TIME COMPLEXITY:
- Best:    O(n)
- Average: O(n¬≤)
- Worst:   O(n¬≤)

SPACE:
- O(1)

STABLE:
- YES

PROS:
- Fast for nearly sorted data
- Fewer operations than bubble sort

CONS:
- Poor performance for large datasets

BEST USED WHEN:
‚úî Array is almost sorted
‚úî Small datasets
‚úî Used as helper in hybrid algorithms

--------------------------------------------------------------------
3Ô∏è‚É£ SELECTION SORT
--------------------------------------------------------------------
TYPE:
- Comparison-based

TIME COMPLEXITY:
- Best:    O(n¬≤)
- Average: O(n¬≤)
- Worst:   O(n¬≤)

SPACE:
- O(1)

STABLE:
- NO

PROS:
- Minimum number of swaps
- Simple logic

CONS:
- Always slow
- Not stable

BEST USED WHEN:
‚úî Swap cost is high
‚úî Memory is limited
‚úî Educational purposes

--------------------------------------------------------------------
4Ô∏è‚É£ RADIX SORT
--------------------------------------------------------------------
TYPE:
- NON-comparison-based

TIME COMPLEXITY:
- O(d * (n + k))
  (Practically O(n) for fixed digits)

SPACE:
- O(n + k)

STABLE:
- YES

PROS:
- Faster than comparison sorts for integers
- Linear time for fixed-size keys

CONS:
- Extra memory needed
- Works only for integers / strings
- Cannot sort floating or generic data easily

BEST USED WHEN:
‚úî Large list of integers
‚úî Fixed digit length
‚úî Speed is critical

--------------------------------------------------------------------
5Ô∏è‚É£ MERGE SORT
--------------------------------------------------------------------
TYPE:
- Comparison-based
- Divide and Conquer

TIME COMPLEXITY:
- Best:    O(n log n)
- Average: O(n log n)
- Worst:   O(n log n)

SPACE:
- O(n) (extra array)

STABLE:
- YES

PROS:
- Guaranteed performance
- Stable
- Very reliable

CONS:
- Extra memory required
- Not in-place

BEST USED WHEN:
‚úî Stability is required
‚úî Large datasets
‚úî Linked lists
‚úî External sorting

--------------------------------------------------------------------
6Ô∏è‚É£ QUICK SORT
--------------------------------------------------------------------
TYPE:
- Comparison-based
- Divide and Conquer

TIME COMPLEXITY:
- Best:    O(n log n)
- Average: O(n log n)
- Worst:   O(n¬≤)

SPACE:
- O(log n) average

STABLE:
- NO

PROS:
- Fastest in practice
- In-place
- Cache friendly

CONS:
- Worst-case O(n¬≤)
- Not stable

BEST USED WHEN:
‚úî General-purpose sorting
‚úî Large datasets
‚úî Memory efficiency is important

--------------------------------------------------------------------
üìä COMPARISON TABLE
--------------------------------------------------------------------

| Algorithm | Best | Avg | Worst | Stable | In-place |
|---------|------|-----|-------|--------|----------|
| Bubble  | O(n) | O(n¬≤) | O(n¬≤) | Yes | Yes |
| Insertion | O(n) | O(n¬≤) | O(n¬≤) | Yes | Yes |
| Selection | O(n¬≤) | O(n¬≤) | O(n¬≤) | No | Yes |
| Radix | O(n) | O(n) | O(n) | Yes | No |
| Merge | O(nlogn) | O(nlogn) | O(nlogn) | Yes | No |
| Quick | O(nlogn) | O(nlogn) | O(n¬≤) | No | Yes |

--------------------------------------------------------------------
üèÜ WHICH SORT IS THE BEST?
--------------------------------------------------------------------

There is NO single best sort for all situations.

‚úî FASTEST IN PRACTICE ‚Üí Quick Sort  
‚úî GUARANTEED PERFORMANCE ‚Üí Merge Sort  
‚úî LINEAR TIME (INTEGERS) ‚Üí Radix Sort  
‚úî NEARLY SORTED DATA ‚Üí Insertion Sort  
‚úî SIMPLEST ‚Üí Bubble Sort  
‚úî LEAST SWAPS ‚Üí Selection Sort  

--------------------------------------------------------------------
üéØ WHICH SORT TO USE ‚Äì QUICK DECISION GUIDE
--------------------------------------------------------------------

‚úî Small data ‚Üí Bubble / Insertion  
‚úî Nearly sorted ‚Üí Insertion  
‚úî Large general data ‚Üí Quick  
‚úî Need stability ‚Üí Merge / Radix / Insertion  
‚úî Integer-only data ‚Üí Radix  
‚úî Low memory ‚Üí Quick / Insertion  
‚úî Worst-case guarantee ‚Üí Merge  

--------------------------------------------------------------------
üß† FINAL ONE-LINE MEMORY RULE
--------------------------------------------------------------------

Bubble    ‚Üí Simple but slow  
Insertion ‚Üí Best for nearly sorted  
Selection ‚Üí Few swaps  
Radix     ‚Üí Integers, fastest  
Merge     ‚Üí Stable & safe  
Quick     ‚Üí Best overall in practice  

====================================================================
END OF SORTING COMPARISON GUIDE
====================================================================
*/
